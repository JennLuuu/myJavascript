# JavaScript
## 入门
01. javascript规范
  * ECMAScript-262
  * ECMAScript x.x
  * ECMAScript 20xx
  * 简称 ESxx

02. ES和JS的关系(*)
  * ES是JS的规范
  * JS是ES的实现语言

03. JavaScript 概念
  * JavaScript是一种直译式脚本语言，是一种动态类型、弱类型、基于原型的语言。它的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，在HTML网页上使用，用来给HTML网页增加动态功能。
  * 直译式：它不需要经过编译器先行编译为机器码在 CPU 中运行。直译式语言需要通过解释器，在运行期动态直接执行。
  * 脚本语言：JavaScript是在程序的运行过程中逐行进行解释，只在被调用时进行解释或编译。
  * 动态类型：变量使用之前不需要类型声明，通常变量的类型是被赋值的那个值的类型。
  * 弱类型：数据类型可以被忽略的语言。它与强类型定义语言相反, 一个变量可以赋不同数据类型的值
  * 基于原型：“原型对象”是基于原型语言的核心概念。原型对象是新对象的模板，它将自身的属性共享给新对象。一个对象不但可以享有自己创建时和运行时定义的属性，而且可以享有原型对象的属性

04. script标签的async和defer属性:(*)
  * 这两个属性主要针对外部引入js的script元素生效
  * 在不书写async和defer属性的时候
    - 浏览器在渲染HTML的时候,一旦遇到外部引入的js,就会停止渲染
    - 开始下载js和执行js
    - 然后才继续渲染HTML
    - 弊端:js中无法操作未渲染的HTML元素,所以只能把script标签放在最下边才可以
  * 添加defer属性的script标签
    - 浏览器渲染HTML的时候,一旦遇到添加了defer属性的外部引入js的script标签,就会开启一个新的线程下载js,并不会停止HTML的渲染
    - 当HTML全部渲染完成,才会依照书写顺序执行下载好的js文件
  * 添加async属性的script标签
    - 浏览器渲染HTML的时候,一旦遇到添加的async属性的外部引入js的script标签,就会开启一个新的线程下载js,并不会停止HTML的渲染
    - 但是一旦有一个js下载完成,就立即停止HTML的渲染,并执行下载好的js
    - 当js执行完成,才会继续渲染HTML
    - 弊端:js执行顺序不固定,需要js之间没有依赖关系;js下载完就执行,会停止HTML渲染,所以不要操作DOM
    - 优点:并行下载js

05. 基础调试语句
  * console.log()方法
    - 控制台打印数据,log()中写什么,就打印什么
    - 遇到console.log()就会在控制台打印,并不会停止代码的运行
    - 常用于调试和纠错
  * alert():
    - BOM提供的方法
    - 操作浏览器弹出一个确认框
    - 弹出弹窗的内容就是alert()中的书写的值
    - 弹窗弹出后会停止代码的执行,直到用户做出选择
  * document.write():
    - 在文档中写入内容
    - 当异步操作的时候,会直接覆盖body中的原有内容

06. 基础词法
  * 严格遵守大小写
  * 起名字要遵守小驼峰命名法(一个单词都是小写,多个单词组成除了第一个单词以外,其他单词的首字母大写),其他需要首字母大写的情况后边再说
  * 注释:单行注释`//`  多行注释`/* */`
  * 标识符(*)
    - 标识符指的是变量、函数、属性的名字，或者函数的参数。
    - 第一个字符必须是一个字母、下划线（_）或一个美元符号（$），其他字符可以是字母、下划线、美元符号或数字  
    - 不能以关键字或保留字命名 

07. 变量:
  * 什么是变量 
    - 变量相当于容器，值相当于容器内装的东西，而变量名就是容器上贴着的标签，通过标签可以找到变量，以便读、写它存储的值
    - ECMAScript 的变量是弱类型，动态类型的,就是可以用来保存任何类型的数据
    - 使用变量可以方便的获取或者修改内存中的数据
  * 声明变量
    - 语法: `var关键字 变量名称  = 数据` 。等号右边的数据给等号左边变量名进行赋值
  * 细节:
    - 声明一个变量没有赋值,则这个变量的值是undefined
    - 可以重复声明变量
    - 可以在一条语句中使用逗号,声明多个变量

08. JS语句:
  * js的语句 使用 `;`结尾,建议不要省略
  * 只有当结尾是 "}"的时候 可以省略";"
  * 语句的操作符的前后建议添加空格,增加美感

## 数据类型

01. 数据类型(*)
  * 数据类型分为两大类 - 基本数据类型 & 复杂数据类型(引用数据类型)
  * 基本数据类型: `number(数值)` `boolean(布尔值)` `string(字符串)` `undefined(未定义)` `null(空)` `symbol(唯一)` `bigint(大整型)`
  * 复杂数据类型: `object(对象类型)`
  * 使用 `typeof 关键字`可以检测数据类型,语法是 `typeof xxx`
  * typeof会检测出一些特殊的值:`typeof检测null得到object(类型应该是null)`,`typeof检测function得到function(类型应该是object)`
  * typeof 检测的结果都放在字符串中返回给我们了

02. 为什么`typeof检测null`结果是`object`
  * 对于 null 来说，很多人会认为他是个对象类型，其实这是错误的。虽然 typeof null 会输出 object ，但是这只是 JS 存在的一个悠久 Bug。
  * 在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息， 000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。
  * 虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。


03. undefined类型:(*)
  * undefined类型只有一个值，即undefined
  * 我们不会对一个值设置undefined，一般都是出现错误的时候，才会被我们打印出来
  * undefined的触发场景
    - 声明变量没有赋值,这个变量值是undefined
    - 函数(方法)调用没有返回值,返回undefined
    - 函数(方法) 被调用的时候,没有传递对应的参数,则这个参数值为undefined
    - 获取对象不存在的属性时,则返回undefined
  * 判断一个值是否是undefined
    - typeof 检测(typeof xx === "undefined")
    - 因为undefined类型只有一个值叫undefined,所以直接判断变量是否等于undefined(xxx === undefined)
      

04. null类型:(*)
  * null类型只有一个值-null
  * 使用场景:
    + 如果定义的变量准备在将来用于保存数据，那么最好将该变量初始化为null而不是其他值 
    + 把一个对象变成垃圾对象
    + 给函数不想传递某个参数的时候,可以使用null来占位
    + 原型链的终点
  * undefined和null
    + undefined和null属于两种不同的类型
    + undefined隐含着意外的空值，而null隐含着意料之中的空值。因此设置一个变量、参数为空的时候，建议使用null而不是undefined
  * 如何判断一个值是null,直接把变量和null进行全等比较(a === null)


05. number:
  * 值的种类
    - 10进制的数值(整数,小数(浮点数),负数)
    - 2进制的数值,0b开头
    - 八进制的数值,0o开头(0开头) 
    - 十六进制的数值,0x开头
    - 科学计数法
    - Infinity / -Infinity
    - NaN
  * NaN的特点
    - NaN 和 任何数值 计算都是NaN
    - NaN 和 任何值 比较都是 false
  * Infinity的特点
    - 向负无穷和正无穷计算的时候,都是Infinity或-Infinity
    - 向0靠拢的时候大多数都是NaN
    - 在项目中大多数出现Infinity都是因为可能某个除数为0
  * isNaN()方法:
    - isNaN方法可以接受任意类型的值,并强制转换为number类型
    - 并检测最终的结果是不是NaN,如果是则返回true 否则返回false
  * 其他类型转number总结:
    - 字符串是纯数字则直接转,如果有其他字符则为NaN
    - 布尔值的true为1 false为0
    - undefined为NaN
    - null为0
    - object大多数都转为NaN(空数组为0,只有一个值的数组根据这个值来转)
  * parseInt()转换规则: 
    - parseInt是一个全局方法,它可以把值转换为整数
    - 第1步,先解析位置0处的字符,如果不是有效数字(或者+ -),则直接返回 NaN。
    - 第2步,如果位置0处的字符是数字,或者可以转换为有效数字,则继续解析位置1处的字符,如果不是有效数字,则直接返回位置0处的有效数字
    - 第3步,以此类推,按从左到右的顺序,逐个分析每个字符,直到发现非数字字符为止
  * parseFloat()转换规则: 
    - parseFloat()也是一个全局方法，它可以把值转换成浮点数，即它能够识别第一个出现的小数点，而第二个小数点视为非法。
    - 解析过程和parseInt相同。  
  * parseInt的基模式
    - parseInt中可以书写其他进制类型的字符串,并转为10进制展示,parseFloat没有这个功能
    - parseInt可以接受第二个参数,代表第一个参数的写法是多少进制,并最终转为10进制展示
    - parseInt的第二个参数如果写0,默认代表10进制
    - parseInt的第二个参数如果写1,没有1进制,所以返回NaN
  * 其他转number的方法:
    - `-` `*` `/` 运算结果都要转为number
    - 最常用 一元运算符(在被转的值之前添加一个 + 即可)可以把一个值转为number

06. String类型:
  * JavaScript字符串(String)就是由零个或多个字符组成的字符序列。零个字符表示空字符串
  * 字符串有三种表示方式:双引号 单引号  反引号(ES6)
  * 字符串注意事项:
    - 字符串中存在单引号双引号反引号等字符,字符串外层需要使用和内部符号不同的引号包裹
    - 字符串中可以使用 \\ (反斜杠)进行转义,把特殊含义的字符转为普通字符,把普通字符转成有特殊含义的字符
  * string类型的拼接
    - 使用加号(+):如果加号两边有任意一边是字符串,则最终会把两边的字符拼接到一起得到一个新的字符串
    - 使用反引号的插值语法,在反引号字符串的内部想要添加变量 可以在把变量书写在${}中即可
  * 字符串的长度和下标:
    - 字符串都有一个length属性,表示当前字符串的长度
    - 字符串的每一个字符都有一个下标,下标从0开始,依次递增
    - 我们可以通过下标拿到对应的字符,比如 str[n]
  * String方法其他类型转string
    - number类型先转为正常的值,然后再加引号转为字符串
    - boolean类型,直接加引号转为字符串
    - undefined和null,直接加引号转为字符串
    - 数组:去掉中括号,加引号转为字符串
    - 对象:直接转为[object Object]
  * toString方法转字符串
    - String方法是全局的方法，直接调用,把被转换的值放在String中即可
    - toString方法是string number boolean 数组 对象等都有的方法(null和undefiend没有toString方法)
    - 当前给某个值直接拼接一个空字符串也可以转字符串

07. boolean类型:
  * boolean类型也被称作为 布尔值类型,包含true和false两个值
  * true表示真  false表示假
  * true和false常用于做判断使用
  * 使用Boolean方法把其他类型转为boolean类型
    - number:非(0和NaN)为true,0和NaN为false
    - string:非空为true,空为false
    - undefined和null都是false
    - 对象类型全部都是true

## 运算符
01. 逗号运算符:
  * 作用 一条语句中可以执行多个操作
  * 返回值 : 返回逗号右侧的值
  * 执行顺序 : 从左到右

02. 赋值运算符:
  * 基础赋值运算符
    - "=" : 把 = 右侧的操作数 赋值 给左侧
    - 左侧的操作数必须是变量、对象属性或数组元素。也称为左值
    - 右侧的操作数可以是任意值
    - 返回值:返回等号右侧的值
    - 执行顺序:从右到左
  * 附加操作的赋值运算:
    - 赋值之前先把左侧操作数在右侧做某种操作,然后把运算结果复制给左侧操作数 比如 += -+  *=  /= %= ||=  &&=  

03. 乘性运算符:
  * 乘性操作符分为  乘法  除法  求模（取余） 
  * 乘性操作符计算 会先把两个值转换成number类型  然后再计算 
  * 执行顺序:从左往右
  * 返回值:返回计算好的值

04. 减法运算符:
  * 减法运算中都会转为 number类型
  * 返回计算好的值
  * 执行顺序:从左向右

05. 加法运算符:
  * 加法操作符除了运算以外，还有字符串拼接的功能
  * 运算规则:
    - 有一个是string,就都转为string 拼接
    - 有一个是object,就都转为string拼接
    - 其他情况都转为number
  * 从左向右运算

06. 递增递减运算符:
  * 递增运算符(++) 递减运算符(--) 目的是让某个变量减1 或者 加1
  * 递增递减运算符还分为两种前置递增递减 和 后置递增递减
  * 无论是前置递增递减还是后置递增递减,都是让变量加1 或 减1
  * 前置和后置不同点在于返回值: 前置返回变量加减后的值,后置返回加减前的值

07. 大小比较运算符:
  * 主要有 `>`  `>=`  `<`  `<=`
  * 返回布尔值
  * 比较规则:
    - 都是number直接比较
    - 有一个是number,都转为number比较
    - 只要没有string,还是按照number比较
    - 都是string,规则:按位比较 按ascII码比较(数字<大写字母<小写字母)

08. 全等和相等:
  * 返回布尔值
  * 相等: 把类型转为一致后,比较是否相等
    - 如果一个操作数是字符串,另一个操作数是数字,则先尝试把字符串转换为数字
    - 如果一个操作数是字符串,另一个操作数是对象,则先尝试把对象转换为字符串
    - 如果一个操作数是数字,另一个操作数是对象,则先尝试把对象转换为数字
    - 如果操作数是布尔值,则先转换为数值,其中false转为0,true转换为1.
    - 如果两个操作数都是对象,则比较引用地址。(后边再学)
    - null和undefined 和除自身以外任何值都不相等,但是null和undefined相等

  * 全等: 先比较类型是否相等 然后再比较值是否相等
    - 未来开发中优先使用全等
  
  * 不相等 : !=
    - 类型不相等,还要看值
    - 1 != "1" //false

  * 不全等 : !== 
    - 类型不等,直接返回true
    - 1 !== "1" //true


09. 逻辑运算:
  * 逻辑运算包含 逻辑与(&&) 逻辑或(||)  逻辑非(!) 三种
  * 逻辑与(&&)
    - 如果都是布尔运算,则一假即假 返回布尔值
    - 逻辑与的真正执行过程(短路原理):
      + 先执行 && 左侧操作数
      + 如果为true(转boolean为true),则执行右边的操作数,并返回右侧操作数
      + 如果为false(转boolean为false)则直接返回左侧操作数
  * 逻辑或(||)
    - 如果两边都是布尔值,则一真即真
    - 逻辑或的真正执行过程(短路原理):
      + 先执行 || 左侧操作数
      + 如果为true,则直接返回左侧操作数
      + 如果为false,则执行右侧操作数,并返回右侧操作数
  * 逻辑非 (!)
    - 把!后的值 转为boolean之后 取反
    - 一定返回布尔值
    - 快速把其他类型转boolean方式(!!)

10. 一元运算符:
  * 只有一个运算数的运算符
  * ++(递增) --(递减) +(一元加,转number) -(一元减,转number并取负) !(转boolean取反) ~(不用)

11. 三元运算符(三目运算符,条件运算符)
  * 由 三个操作数 和 `?` `:`组成
  * 语法 `判断式1 ? 表达式2 : 表达式3`
  * 执行过程:如果判断式1为true,则执行表达式2,否则执行表达式3
  * 返回值: 如果判断式1为true,则执行表达式2,并返回表达式2的返回值,否则返回表达式3的返回值

## 语句:
1. 声明语句:
  * 声明语句包含三种：声明变量、声明函数和声明标签
  * 总结:
      - 使用var声明函数作用域变量
      - 使用let声明块作用域变量
      - 使用const声明常量
      - 使用function声明函数
      - 使用label给循环声明一个标签名
      - 使用class声明一个类

2. if语句:
  * 分为单分支 双分支 多分支,用来条件判断并执行对应的操作
  * 单分支
    - 书写格式：if (判断式){代码块}
    - 如果判断式为真，则执行代码块。
    - 判断式不一定要书写各种操作符，无论传递什么进去，if都会把它转换成布尔值 然后执行if代码
    - 一般有 (当。。。。的时候)  使用if语句
    - 如果if语句中只有一条语句,则可以省略`{}`
  * 双分支
    - 比单分支多了一个else语句
    - else语句仅在if或者else/if语句的条件表达式为假的时候执行。
    - if（判断式）{代码块1}else{代码块2}
    - else语句中如果只有一句话也可以省略大括号
  * 多分支
    - else if语句 可以构成多分支,else if是在否则的基础上再次书写条件
    - if (条件表达式) {语句1;} else if (条件表达式) {语句2;} ... else {语句3;}

3. switch语句:
  * switch语句专门用来设计多分枝条件结构。与else/if多分支结构相比，switch结构更加简介，执行效率更高。 
  * switch语句根据传递的值,依次与case后的表达式的value值进行比较。如果相等，则执行其后的语句段，直到遇到break，或者switch语句结束才中止，
  * switch语句包含了一个可选的default语句(switch的异常处理)，如果前边的case没有找到相等的条件，则执行default语句，它与else语句类似。
  * switch语句是使用全等（===）来检测两个只的相等与否。所以会有一个值类型的比较
  * case后可以是一个空语句，把多个条件放在一起检测

4. while循环:
  *  while语句是最基本的循环结构
  *  当判断式为真的时候，执行语句。执行结束之后再次进行判断，直到判断式为假，才跳出循环
  * 请注意,一般情况下,我们要在循环语句中修改判断式的条件,防止进入死循环

5.  do{}while();
  * do/while与while循环非常相似，区别在与表达式的值是每次循环结束后去检查，而不是开始去检查。 
  * 因次do/while循环能够保证至少执行一次循环。而while就不一定了。

6. for循环:
  * 首先执行语句1
  * 执行判断式2 如果成立（返回true）则执行代码块  如果不成立（返回false） 整个循环结束
  * 如果判断式成立去执行了代码块，执行完代码块 会去执行语句3
  * 语句3执行完成后  再次去执行判断式2
  * 重复第二个步骤

7. break和continue:
  * break:
    - 除了可以退出switch以外,还可以退出循环(while do..while for)
    - 直接退出整个循环,执行循环后的语句
  * continue:
    - 退出循环(while do..while for)
    - 只退出当次循环,执行下一次的循环

8. label声明:  
  * 在JS中，label语句可以为一行语句添加标签，以方便在复杂的结构中设置跳转目标。
  * 语法如下：label名称:语句
  * label和break语句continue语句配合使用，以便与跳出内层或外层循环体。

9. 错误对象:
  * ECMA-262规范了7种错误类型。其中Error是基类，其他6种错误类型是子类，都继承了基类。Error类型的主要作用是自定义错误对象。
  * Error：普通异常 。与thorw语句和try/catch语句一起使用，属性name可以读写异常类型，message属性可以读写详细的错误信息。
  * SyntaxError：出现语法错误时抛出 `var a = 1!`
  * ReferenceError：读取不存在的变量时抛出 'var b = c;'没有声明c
  * TypeError：值的类型发生错误的时候抛出 'undefined.name'
  * EvalError：不正确使用eval()方法时抛出(不常见)
  * RangeError：数字超出合法范围之抛出(不常见)
  * URIError：URI编码和解码错误时抛出(不常见)

10. 手动抛出异常:
  * 在一些我们自己封装的代码中,如果没有按照我的规范使用,可以选择抛出自定义异常
  * 使用 new XXXError("异常信息") 创建一个异常
  * 使用 throw 关键字 抛出异常

11. try..catch...finally语句
  * 代码中可能会有出现意外报错的代码,一旦报错就会停止运行
  * 我们可以把可能出现意外的代码放在try中
  * 如果try中抛出了异常,就会直接进入catch中捕获异常,并不会停止try语句后的代码运行
  * 无论try中是否有异常,最终都会进入finally中执行(finally是可选的)\
  * catch后的小括号接受一个参数e,代表try中出现的错误,e中有一个message属性,代表错误信息

## 函数
01. 什么是函数
  * 什么是函数???
    - 当一段代码要被重复执行的时候,可以封装在函数内部,随时调用函数,可以重复执行函数内部的代码
    - 创建一个独立的作用域
  * 声明函数的方式
    - 函数声明方式 function 函数名(形参){函数体}
    - 函数表达式方式 var 变量名 = function (形参){函数体}
    - 实例化Function方式 var 变量名 = new Function("形参","形参",...."函数体");(不常用)
  * 函数的调用
    - 定义的函数并不会自动执行。定义了函数仅仅是赋予函数以名称并明确函数被调用时该做些什么。
    - 调用函数才会以给定的参数真正执行这些动作
    - 使用`函数名()`这种方式可以调用函数
  * 函数的返回值
    - 函数提供两个接口与外界的交互，其中参数作为入口，接受外界的信息。返回值作为出口，把运算结果反馈给外界。
    - 我们封装函数的时候,根据需要可以控制函数是否返回值,如果需要函数一个反馈,则要书写返回值
    - 函数内部使用return 关键字返回数据
    - 调用函数有返回值,请务必接收,否则拿不到
  * return的作用
    - 返回 函数返回值
    - 退出函数
  * 函数的参数
    - 形参: 封装函数的时候,定义的占位的参数 称作为形参,形参只能在当前函数内部使用
    - 实参: 调用函数的时候,传入的实际参数值, 称作为实参
    - 形参和实参是按照顺序一一对应的,如果没有传递,则当前形参的值是undefined
    - 如果不想给某个形参传递实参值,可以传递一个null
    - 形参和实参的个数可以不一致
  * arguments
    - arguments对象表示函数的实参集合,仅能够在函数体内可见,并可以直接访间。
    - arguments对象拥有length属性值，可以通过下标访问每一个实参。

02. 变量作用域：
  * 变量作用域（scope）是指变量在程序中可以访问的有效范围。也称为变量的可见性。分为全局变量和局部变量
  * 全局变量：变量在整个页面中都是可见的，可以被自由的访问
  * 局部变量，变量仅能在声明的函数内部可见，函数外是不允许访问的

03. 执行上下文:
  * JS其实是一段一段解析的,JS执行的代码段分为两种类型: 全局代码段 局部代码段(函数代码段)
  * JS在要执行某个代码段之前,会做一个准备工作(1. 在内存中开辟一块空间 2.创建变量对象 3.确定this指向 4.确定作用域链),这个准备工作就被称作为"执行上下文"
  * JS执行每一段代码都有执行上下文,在脚本中可能会出现多个执行上下文
  * 因为有太多的执行上下文， JS创建了一个执行上下文栈（stack） 用来管理执行上下文
  * 当js开始解析程序的时候，最先遇到的全局代码段，此时向执行上下文栈中 压入一个全局执行上下文，全局执行上下文一定是在页面关闭才会从栈中弹出
  * 当执行一个函数的时候  会创建一个函数的执行上下文，并压入到执行上下文栈中，只要函数执行完成，会将函数从栈里弹出

04. window:
  * 浏览器(BOM)有一个顶层对象叫做window,浏览器中方法属性都是window对象上的(比如alert propmt)
  * ES也有一个顶层对象叫做Global(但是浏览器没有实现它),浏览器让window代理了Global的作用,很多全局的方法都在window对象上
  * window的作用:
    1. BOM的顶层对象
    2. 替代Global作为ES的顶层对象
  * 全局的变量和全局函数,其实都是属于window对象的属性和方法

05. 变量对象:
  * 每个执行上下文 都有三个重要属性：1.变量对象（VO） 2.作用域链  3.this 
  * 只要在一个执行上下文中,变量对象就会被激活,变量对象储存了 在上下文中定义的 变量和函数声明 
  * 全局的变量和函数就是window对象属性和方法,全局执行上下文的变量对象其实就是全局对象window
  * 局部执行上下文的变量创建,首先变量对象包括了函数所有的形参和实参(arguments)
  * 检查所有声明的函数。如果变量对象已经有相同名字的属性，则完全替换
  * 检查所有的声明的变量,值为undefined,如果变量名和已经声明的形参或函数相同，则变量声明不会干扰已经存在的这类属性

05. 作用域链:
  * 当代码在一个环境中执行时,会创建变量对象组成的一个作用域链(scope chain),作用域链的用途,是保证对执行环境有权访问的所有变量和函数的有序访问。
  * 作用域链的前端,始终都是当前执行上下文变量对象
  * 全局执行环境的变量对象(window)始终都是作用域链中的最后一个对象。
  * 作用域链是在函数声明的时候已经创建了,当函数被调用的时候创建了自己的变量对象,才补全了作用域链
  * 标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐级地向后寻找,直至找到标识符为止(如果找不到标识符,通常会导致错误发生)

06. this:
  * 函数的调用方式是不确定的,因此JS在函数体内定义了this关键字,用来获取当前的运行环境
  * this是一个指针型变量,它动态引用当前的运行环境,具体来说,就是调用函数的对象
  * this指向总结:this永远指向其所在函数的调用者,如果没有调用者,则规定this指向window
  * 判断this指向:
    - 先看是否是实例化调用(new 调用),this指向实例化对象
    - call和apply调用,就会把this指向call和apply的第一个参数(如果没有就为window)
    - 上下文对象调用,this指向上下文对象
    - 默认调用的函数,this指向window
    - 全局作用域中直接获取this,指向的是window

07. IIFE:(匿名函数自调用)
  * 函数分为了 匿名函数和具名函数
  * 匿名函数的主要目的其实是提供一个独立的作用域
  * 匿名函数的调用方法:
    1. 赋值给一个变量
    2. 自调用(使用括号扩住整个函数,直接调用)


## 对象
01. 创建对象:
  * 实例化构造函数 `new Object({})`
  * 对象直接量(对象字面量) `var o = {}`

02. 对象的操作:
  * 增: 直接给对象使用 `.`(成员访问)操作符 扩展一个新的属性,并赋值
  * 改: 直接拿一个值, 给对象使用 `.`(成员访问)操作符获取的属性 重新赋值即可
  * 查: 获取某个属性值,给对象使用 `.`(成员访问)操作符获取的属性值
  * 删: 使用delete关键字 删除对象的某个属性

03. 点操作符和中括号操作符
  * 点操作符: 成员访问(直接把点后边的字符作为属性名去寻找和新增)(.后边其实书写的内容都被默认为字符串)
  * 中括号操作符: 需计算的成员访问(中括号内可以书写一个值或者变量,如果是变量,则先解析变量得到值,把值作为属性名去解析)

04. for in循环
  * 专门用来遍历对象的
  * for(var key in obj){}
  * 每次循环都会拿到key,我们通过key再拿到对应的value

05. 变量类型和数据类型
  * 变量类型:
    - 变量类型按照变量保存的值划分
    - 变量类型分为 基本类型 和 引用类型
  * 数据类型:
    - 数据类型按照数据的存储区域划分
    - 数据类型分为 基本类型 和 复杂类型(对象类型)

06. 基本类型特点:
  * 基本类型值：null  undefined  string  number  boolean symbol bigint
  * 特点:
    - 基本类型值是直接保存在栈中,可以通过变量名直接访问到值
    - 基本类型的值是不可变的(所有对字符串的操作都是返回一个新的字符串,原字符串不可能被修改)
    - 我们不能给基本类型值添加属性和方法  就算添加也是获取不到的
    - 基本类型值的比较是值的比较

07. 对象类型值特点：
  * 对象类型有：object array function regexp date ...
  * 对象类型特点：
    - 对象类型值都是保存在堆中,然后把引用地址保存在栈中,我们可以通过栈中的地址访问到堆中的数据
    - 我们可以给对象类型值添加属性和方法
    - 对象类型值是可变的
    - 对象类型的比较(引用类型的变量的比较) 都是引用地址的比较
    - 对象类型的赋值(引用类型的赋值)都是引用地址的赋值
    - 如果一个对象没有任何引用了,则这个对象就会变成垃圾对象,等待浏览器的垃圾回收机制回收

## 数组
01. 什么是数组
  * 数组(Array)是有序数据集合(1.存放多个数据 2.有序)
  * 数组中的每个成员被称为元素,每个元素都有下标(index)
  * 数组内不同元素的值可以为不同类型,但是一般使用都是保存同类型的值

02. 创建数组:
  * 实例化方式 `new Array()`,如果是多个参数,代表初始数据,如果只有一个参数并且是number,代表新数组长度
  * 字面量方式 `var arr = []`;

03. 数组的下标和长度:
  * 数组有一个length属性,表示数组的长度,数组的lenght属性是可读可写的!!
  * 数组的每一个元素都有一个下标,可以通过`[]`来获取或者设置对应下标的值

04. 数组结构的栈和队列操作(数组两头的删除和新增)
  * push方法:
    - 功能:向数组的末尾添加一个或多个新的元素
    - 返回值: 修改了原数组 并返回数组添加元素后的长度
    
  * pop方法:
    - 功能:删除数组最后一个元素
    - 返回值: 修改了原数组,并返回被删除的元素

  * unshift方法:
    - 功能:向数组的最前边添加一个元素,其他元素向后位移
    - 返回值: 修改了原数组 并返回数组添加元素后的长度

  * shift方法:
    - 功能:删除数组第一个元素
    - 返回值: 修改了原数组,并返回被删除的元素

05. 删除数组的元素:
  1. pop: 删除数组末尾的元素
  2. shift: 删除数组第一个元素
  3. delete关键字,可以删除某个位置的值,但是元素占用的空间还在(很少使用)
  4. length长度:改变数组的长度,可以删除数组长度以外的所有元素(很少使用)
  5. splice方法: 删除某个位置的元素
    - 参数1:删除元素的起始下标
    - 参数2:删除元素的长度(为0就是不删除)(如果不写,默认删除后边所有的元素)
    - 返回值:修改原数组,返回被删除元素组成的新数组

06. 给数组添加元素:
  * push : 向数组的末尾添加一个或多个元素
  * unshift : 向数组的开头添加一个或多个元素
  * 通过下标的方式: 给某个固定的位置添加元素
  * splice方法:
      - 参数1: 删除开始的位置(插入开始的位置)
      - 参数2: 删除的长度(如果只插入不删除,则书写0即可)
      - 参数3...: 在删除的位置,插入的元素
      - 如果删除了并插入被称作替换,如果没有删除插入了则被称作为添加
  * concat方法:
    - 合并数组
    - concat方法可以跟随多个参数,并把它们作为元素按顺序连接到数组的尾部
    - 如果参数是数组,则concat方法会把它打散,分别作为单独的元素连接到数组的尾部(只能打散一维数组)
    - concat方法不会改变原数组,只能返回一个合并过值的新数组

07. slice方法
  * 截取数组中的值
  * 参数1:开始截取的位置(包含)
  * 参数2:截取的结束位置(不包含)
    - 如果不写,则默认截取到末尾
    - 如果为负数,则倒着取结束位置,如果不想要最后一个值,则书写-1
  * 不修改原数组,返回被截取的元素组成的新数组

08. 数组的翻转:
  * reverse方法
  * 作用:翻转数组
  * 改变了原数组,并返回原数组的引用

09. sort排序:
  * sort可以让数组内部的元素排序(默认是升序)
  * sort修改了原数组,并返回对原数组的引用
  * 如果让数组的字符串元素排序,则是按照字符串比较的方式进行比较的(按位的ascII码比较)
  * sort可以接受的一个回调函数作为参数  
    - 回调函数接受数组的某个两个数值作为参数(a,b)(其中a是后边的值,b是前边的值)
    - 如果回调函数返回一个负数,则交换两个数的位置,否则不交换
    - 所以在回调函数内部 return a-b 则表示升序  return b-a 则表示降序

10. 数组转换-join方法
  * join是空参,则去中括号加引号
  * join中书写的参数,就是转字符串时,每一个元素链接的符号
  * 返回字符串,不会修改原数组
  * 内部的元素除了null和undefined转为空字符串外,其他类型元素都是调用toString()方法转的字符串

11. indexOf和lastIndexOf
  * 寻找某个元素 在数组中第一次出现时候的下标
  * indexOf是从前向后寻找
  * lastIndexOf是从后先前寻找
  * 如果在数组中找不到某个值,则直接返回 -1(这个是通常用来检测数组中是否有某个值)

12. includes方法:
  * 用来判断某个元素是否在数组中存在
  * 如果存在则返回true,否则返回false
  * 判断是全等判断,对象的比较都是地址的比较

13. forEach方法:
  * 单纯的遍历数组
  * forEach接受一个回调函数作为参数,回调函数接受3个参数
    - item: 当前遍历到的元素
    - index: 当前遍历到的元素的下标
    - array: 当前被遍历数组的引用
  * forEach没有返回值

14. some方法:
  * 遍历数组 并判断 得到布尔值
  * some方法书写和forEach一样
  * 但是如果some方法的回调函数中,只要有一个返回true,则some返回true,并停止遍历

15. every方法:
  * 遍历数组,接受一个回调函数作为参数
  * 如果有一个回调函数返回false,则every方法停止遍历,直接返回false

16. map方法:
  * 映射数组,遍历数组,接受一个回调函数作为参数
  * 每次回调函数的返回值,都会放入新数组中

17. filter:
  * 过滤数组,遍历数组,接受一个回调函数作为参数
  * 返回一个新数组
  * 只要回调函数返回true,则把本次的元素放入新数组中
  * 删除数组中某一个元素使用splice 删除数组多个元素使用filter

18. reduce:
  * 累加,接受一个回调函数作为参数,再接受一个参数作为累加的初始值
  * 回调函数参数:
    - 1: 初始值或者上次累加后的值
    - 2: 当次遍历数组的值
    - 3: 当次数组的下标
    - 4: 原数组的引用
  * 回调函数要返回一个值,作为下一次遍历时的previous参数
  * reduce返回最后累加的结果

19. toString方法:
  * 数组隐式转字符串 默认调用的都是自己的toString方法
  * toString方法 是去中括号加引号
  * toLocaleString转是加上本地特色的

20. 算法：
  * 解决程序问题的一种方法，使用不同的算法，得到的结果是一样的，但是过程中消耗的时间或者内存是不一样的
  * 算法中的优劣是从两个维度考虑的
    - 时间复杂度:执行当前算法需要占用的时间
    - 空间复杂度:执行当前算法需要占用的内存
  * 在排序算法中还有一个检测算法的特点:排序算法的稳定性
    - 排序算法中,有多个相同的数据,经过排序之后,这些相同的数据前后顺序保持不变,则称这个排序算法是稳定的,否则不稳定
          
        
21. 时间复杂度(T(n)):
  * 常数阶(O(1)):无论代码执行多少行,只要没有循环结构,则基本都属于常数阶
  * 线性阶(O(n)):当有一层循环的时候,基本属于线性阶
    - for(var i = 1; i < n; i++){}
  * 线性阶(O(2n)):当有一层循环的时候,基本属于线性阶
    - for(var i = 1; i < n; i++){}
    - for(var j = 1; j < n; j++){}
  * 对数阶(O(logN))
    ```js
      var i = 1;
      while(i<n){
        i *= 2;//循环x次 说明 2的x次方等于n  x = log2N
      }
    ```
  * 线性对数阶(O(NlogN))
    ```js
      var i = 1;
      for(var j = 0; j < n; j++){
        while(i<n){
          i *= 2;//循环x次 说明 2的x次方等于n  x = log2N
        }
      }
    ```
  * 平方阶(O(n^2))
    ```js
      for(var i = 0; i < n; i++){
        for(var j = 0; j < n; j++){
        
        }
      }
    ```

22. 空间复杂度(S(n))
  * 空间复杂度是算法在执行的时候,临时占用的内存的量
  * 常数阶(O(1)): var i = 1;var j = 2;
  * 线性阶(O(n)): var arr; fori(arr.push(i))

## 字符串
01. 拼接字符串:
  - 使用`+`拼接多个字符串(推荐)
  - 使用concat方法拼接字符串

02. 字符串查找:
  * 使用下标,找不到返回undefined
  * charAt(n),根据下标n查找字符串,找不到返回空字符串
  * indexOf和lastIndexOf:查询字符串出现的下标,如果没有返回 -1
  * includes:查询是否存在某个字符串，返回布尔值
  * search:查询字符串第一次出现的位置，但是可以使用正则查询(如果想要查询出现的位置默认使用indexOf，如果需要使用正则查询，则使用search)
  * match:查询字符串中符合正则条件的字符串，并收集在数组中并返回出去

03. 字符串截取:
  * slice(推荐): 和数组方法一致 
    - 第一个参数是起始位置
    - 第二个参数是结束位置（不包含） 可以为负数,不写默认截取到最后
  * substring:
    - 和slice基础用法相同
    - 如果第二个参数小于第一个参数,则交换参数的位置,如果截取不到返回空字符串
  * substr:
    - 第一个参数是起始位置
    - 第二个参数是截取长度

04. 字符串大小写转换:
  * toLowerCase(): 转为小写
  * toUpperCase(): 字符串转为大写

05. 字符串转数组:
  * split方法: 以某种方式 切割字符串并转为数组
  * 如果没有书写参数,则把字符串直接放入数组,只有这一个值
  * 如果参数是一个空串,则每一个字符都是数组的一个值
  * 如果参数是其他字符,则以这个字符切割

06. 字符串去前后空格:
  * trim方法:去两侧空格
  * trimEnd方法:去结尾空格
  * trimStart方法:去前边空格

07. 基本包装类型:
  * 创建字符串数字布尔值有两种方式,一种是字面量(最常用),第二种是实例化方式(创建包装类型方式)
  * 我们无法直接对字面量类型进行属性的操作,只能给包装类型的数据操作属性
  * 当我们只要对字符串数字布尔值的字面量的值操作属性的时候,就会内部自动的装箱并操作
  * 装箱和拆箱
    - 装箱：把基本类型数据转为其包装类型
    - 拆箱：把包装类型数据转为其基本类型


## Math
01. Math对象的属性:
  * Math.PI: 圆周率
  * Math.SQRT2: 根号2
  * Math.SQRT1_2: 二分之一的平方根

02. Math的方法:
  * Math.abs():绝对值
  * Math.ceil():向上取整
  * Math.floor():向下取整
  * Math.round():四舍五入
  * Math.min()和Math.max() 计算一组数值中的最大值和最小值
  * Math.pow(m,n):求m的n次方 (现在用 ** 操作符即可)
  * Math.sqrt():平方根
  * Math.sin(),Math.cos(),Math.tan():三角函数 内部书写的是弧度不是角度
  * Math.random():随机数，生成随机数的范围: [0,1)

03. 创建时间:
  * new Date() 创建一个当前的时间对象

04. 把时间转为字符串:
  * toString():Fri Apr 12 2024 15:14:33 GMT+0800 (中国标准时间)
  * toDateString():Fri Apr 12 2024
  * toLocaleDateString():2024/4/12
  * toLocaleString():2024/4/12 15:15:24
  * toLocaleTimeString():15:15:46
  * toTimeString():15:16:07 GMT+0800 (中国标准时间)

05. 创建某个时间点的时间对象
  * new Date("xxxx-xx-xx xx:xx:xx") :字符串表示法
  * new Date(xxxx,xx,xx,xx,xx,xx,xxxx): 数字表示法(月份是从0开始的)
  * new Date(xxxx):时间戳

06. 获取详细时间:
  * getYear(不用)
  * getFullYear:获取完整的年份
  * getMonth():获取月份(月份从0开始)
  * getDate():获取日期
  * getHours():获取时
  * getMinutes():获取分
  * getSeconds():获取秒
  * getMilliseconds():获取毫秒
  * getDay():获取星期
  * getTime():获取时间戳

07. 设置详细的时间
  * setFullYear:设置年
  * setMonth:设置月份
  * setDate:设置日期
  * setHours:设置时
  * setMinutes:设置分
  * setSeconds:设置秒
  * setMilliseconds:设置毫秒

08. 获取一个时间戳:
  * 时间对象.getTime()
  * valueOf方法:获取原始值
  * 把时间对象转number类型
  * Date.now() : 拿当前时间的时间戳

## 正则表达式
01. 创建正则表达式:
  * 实例化RegExp类的方式:参数1:正则表达式 参数2:正则修饰(g:全局,i:忽略大小写)
  * 字面量方式: /正则/修饰

02. 正则检测方法:
  * 正则方法:test():查询字符串是否符合正则规则,返回布尔值
  * 字符串方法:search():查询符合正则的字符串在当前字符串中第一次出现的位置,如果没有则返回-1
  * 字符串方法:match():把匹配到的数据放到数组中
  * 字符串方法:replace():把匹配的到的字符串替换为其他字符串
  * 字符串方法:split():可以通过某个正则切割字符串

03. 正则书写:
  * 中括号:中括号代表一个整体，并且括号中的字符属于或者关系，只挑选一个出来匹配
    - [abc]:a或b或c
    - [大帅比]:大 或 帅 或 比
    - [a-z]:匹配所有小写字母
    - [0-9]:匹配所有数字
    - [a-z0-9]:匹配所有小写字母和数字
    - [3-9]: 匹配 3-9 的数字
    - [^0-9]: 排除 0-9 其他所有都匹配
 
  * 转义字符
    - . : 表示匹配所有字符,除了换行符(\. 代表匹配 .)
    - \b : 匹配单词边界
    - \d : 匹配数字 和 [0-9]一样
    - \s : 匹配空白字符串
    - \w : 匹配任意一个字符( 字母、 数字、下划线 )
    - 所有字母如果写成大写,则代表和小写的含义相反

  * 量词
    - + : 一个或多个
    - ? : 0个或1个
    - * : 0个或多个
    - {x}: x个
    - {x,y}:最少x个，最多y个
    - {x,}:最少x个
    - ^ : 字符串以xxx正则匹配的字符串开头
    - $ : 字符串以xxx正则匹配的字符串开头
    - | : 或者

## 其他
01. 检测数据类型:
  * typeof : 
    - string number boolean undefined正常检测
    - null检测为object,function检测为function
    - 其他一律都是object
  * 全等:
    - 只能检测 null 和 undefined
  * Object上的toString可以检测具体类型
    - Object.prototype.toString.call(arr).slice(8, -1).toLowerCase()

02. call,apply和bind:
  * call apply bind 都是函数的方法
  * 主要目的是为了改变函数的this指向
  * this指向规则(1.如果参数是对象,则指向该对象 2. 如果是基本类型,则指向其包装对象 3.如果是null或者undefined,则指向window)
  * call和apply作用
    - 调用函数
    - 改变函数执行时的this指向为 call或者apply的第一个参数
  * call和apply的区别
    - 只有给被调用的函数传参方式区别
    - call是从第二个参数开始依次写入参数
    - apply是把所有的参数放在数组中,传递给apply的第二个参数
  * bind的作用
    - 返回一个新的函数,新的函数的this指向其第一个参数
    - 传参方式和call一致

03. 节流函数封装
  ```js
    function throttle(center, time) {
      var lastTime = 0;
      //内部返回的函数才是真正的事件函数
      return function () {
        // console.log(this, "!!!!!!");
        var nowTime = Date.now();
        if (nowTime - lastTime < time) {
          return;
        }
        lastTime = nowTime;
        center.call(this);
      };
    }
  ```

04. 防抖函数封装
  ```js
    //封装一个防抖函数
    function debounce(fn, time) {
      var timer = null;
      return function () {
        // console.log(this);
        var _this = this;
        //一旦我重新触发了当前事件函数,就让上次的延迟执行定时器停止了
        clearTimeout(timer);
        //延迟执行fn函数
        timer = setTimeout(function () {
          fn.call(_this);
        }, time);
      };
    }
  ```

## BOM
01. 全局变量:
  * 创建方式:
    - 在全局作用域中直接声明变量
    - 在任何位置 通过给window对象扩展属性创建全局变量
    - 在任何位置 通过给一个没有声明的变量赋值,则这个变量也是全局变量
  * 变量污染:全局变量在全局作用域内都是可见的,因此具有污染性。大量使用全局变量会降低程序的可靠性,用户应该避免使用全局变量 

02. 内存泄漏:
  * 内存泄漏是指程序中已动态分配的堆内存已经不再有效
  * 但是由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致可用空间变少

03. 内存溢出:
  * 内存溢出是指应用系统中存在无法回收的内存或使用的内存过多，最终使得程序运行要用到的内存大于能提供的最大内存。
  * 此时程序就运行不了，系统会提示内存溢出，有时候会自动关闭软件，重启电脑或者软件后释放掉一部分内存又可以正常运行该软件

04. window上的系统对话框:
  * alert:系统警告框,弹出的内容都会被转为字符串
  * confirm:系统确认框,包含确认和取消两个按钮,返回布尔值
  * prompt:输入取消确认框,还提供了输入框,返回输入的内容

05. 打开和关闭窗口:
  * window.open()既可以导航到一个特定的 URL，也可以打开一个新的浏览器窗口
    - url：需要载入的地址
    - 新窗口的打开方式：_self  _blank
    - 新窗口的属性(当打开方式是_blank的时候有效)：窗口的大小  位置。例如：width=300,height=300,left=200,top=100

  * window.open()返回值:打开的新窗口
  * xxxwindow.close():关闭某个window窗口

06. 延迟调用定时器：
  * setTimeout():延迟调用定时器：
  * 参数：
    - 参数1：可以是一个字符串，内部是可执行代码，也可以是一个函数
    - 参数2: 是一个以毫秒为单位的时间
    - 参数3...:当参数1是一个函数的时候,给函数传递的实参
  * 当定时器定时结束,如果第一个参数是字符串,则解开字符串并执行,如果第一个参数是函数,则直接调用函数,并把后边的参数传递给函数
  * 定时器返回一个id值(timerID)
  * 清除延迟调用定时器 clearTimeout(timerID)

07. 间歇调用定时器:
  * setInterval()
  * 写法和setTimeout一致
  * 每隔一段时间,执行一次第一个参数的代码或者函数
  * 间歇调用定时器返回一个timerID
  * 可以通过clearInterval(timerID)清除对应的定时器
     
08. navigator对象:
  * 存储了与浏览器相关的基本信息,如名称、版本和系统等。 
  * 常见属性
    - onLine:表示浏览器是否连接到因特网
    - platform:浏览器所在的系统平台
    - userAgent:浏览器的用户代理字符串(关于浏览器的详细描述)

09. location对象:
  * protocol属性 :协议
  * host属性 : 主机地址+端口号
  * hostname属性 : 主机地址
  * port属性 : 端口号
  * hash属性 : 哈希值
  * origin属性 : 完整源地址(协议+主机地址+端口号)
  * **** href属性 : 完整地址(完整源地址+路径)[可读可写](可以做重定向)
  * reload方法: 刷新页面
  * assign方法 : 和href属性一样 重定向用的
  * replace方法: 重定向,用新的地址替换当前地址的历史记录



## DOM
01. 什么是DOM
  * DOM( Document Object Model,文档对象模型)是W3C制订的一套技术规范,用来描述 Javascript脚本如何与HTML进行交互的Web标准
  * DOM规定了一系列标准接口,允许开发人员通过标准方式访问文档结构、操作网页内容、控制样式和行为等
  * 在DOM中，接口可以理解为就是函数（函数  方法  API  接口  本质上都是一个函数）

02. 什么是节点
  * 在网页中所有对象和内容都被称为节点。
  * 如文档、元素、文本、属性、注释等。
  * 节点(Node)是DOM最基本的单元,并派生出不同类型的节点,它们共同构成了文档的树形结构模型。

03. document对象:
  * document对象是window对象的一个属性
  * document是DOM的顶层对象,当浏览器载入 html文档, 它就会成为 Document 对象

04. 节点及节点的判断:
  * childNodes: 获取一个元素所有的子节点
  * nodeType:获取节点的类型
    - 元素节点:1
    - 文本节点:3
    - 注释节点:8
    - 文档节点:9
    - 属性节点:2
  * nodeName:获取节点的名称
    - 元素节点:大写标签名
    - 文本节点:#text
    - 注释节点:#comment
    - 文档节点:#document
    - 属性节点:属性名
  * nodeValue:获取节点的值 
    - 元素节点:null
    - 文本节点:文本内容
    - 注释节点:注释内容
    - 文档节点:null
    - 属性节点:属性值

05. 伪数组:
  * 其实是一个对象
  * 对象被称作为伪数组的要求
    - key从0开始依次递增
    - 拥有length属性
  * 常见的伪数组,比如 arguments

06. 获取元素节点:
  * 通过id获取:document.getElementById("id值")
    - 如果获取不到则返回null
  * 通过类名获取:document.getElementsByClassName("类名");
    - 得到一个HTMLCollection集合对象,是一个伪数组
  * 通过标签名获取:document.getElementsByTagName("标签名")
    - 得到一个HTMLCollection集合对象,是一个伪数组
  * HTML5新API:document.querySelector("选择器")
    - 根据选择器 选择某个一个元素
  * HTML5新API:document.querySelectorAll("选择器")
    - 根据选择器,选择所有被选中的元素
    - 得到一个NodeList集合,拥有forEach方法

07. 新旧获取元素节点的区别
  * 旧方法:
    - 使用旧的方式获取元素得到的集合是HTMLCollection集合
    - HTMLCollection集合是动态的!!!
    - 将来只要新的元素或者删除元素,则对应的HTMLCollection集合也会发生改变
  * 新方法:
    - 使用新的方式获取元素得到的集合是NodeList集合
    - NodeList集合是静态的!!!
    - 将来新增元素或者删除元素,对集合没有任何影响
    - 想要得到最新的集合 需要重新获取

08. 节点关系获取节点：
  * childNodes: 获取所有的子节点(使用比较少，因为我们经常性的只需要元素节点)
  * children: 获取所有的字元素节点(HTMLCollection集合)
  * firstElementChild: 获取第一个子节点
  * lastElementChild: 获取第一个子节点
  * previousElementSibling:获取上一个兄弟节点
  * nextElementSibling:获取下一个兄弟节点
  * parentNode: 获取父节点

09. 快速获取html和body:
  * document.body: 获取body元素
  * document.documentElement:获取html元素
  * document.head:获取head元素

10. JS事件:
  * 获取焦点事件-focus
  * 失去焦点事件-blur
  * 
  * 左键单击事件-click
  * 右键单击事件-contextmenu
  * 左键双击事件-dblclick
  * 
  * 键盘按下事件-keydown
    - 如果是表单，则绑定给表单元素
    - 如果不是表单,则绑定给document
  * 键盘抬起事件-keyup

  * 表单改变事件-change
    - 如果是输入框,则只有改变并失去焦点才触发
  * 表单改变事件-input
    - 如果是输入框,则只要改变就触发

  * 鼠标按下事件-mousedown
  * 鼠标抬起事件-mouseup
  * 
  * 鼠标移入事件-mouseover(冒泡)
  * 鼠标移出事件-mouseout(冒泡)
  * 鼠标移入事件-mouseenter(不冒泡)
  * 鼠标移出事件-mouseleave(不冒泡)
  * 鼠标移动事件-mousemove
  * 
  * 鼠标滚动条事件-scroll
    - 不管使用什么方式,只要滚动条位置改变,则会触发

  * window.onload事件
    - 常用在window.onload,表示当页面的节点及所有资源(音频,视频等等)全部加载完毕后执行
    - 优点:让代码在节点加载完成后执行
    - 缺点:让代码要等到所有资源加载完成后执行

  * window.onscroll事件
    - 当整个窗口的滚动条滚动后触发

11. 脚本化css-设计大小
  * offsetWidth和offsetHeight:获取元素内容+内边距+边框的宽度
  * clientWidth和clientHeight:获取元素内容+内边距的宽度
  * 当元素被display:none的时候,他们的值为0

12. 脚本化css-设计位置
  * offsetLeft和offsetTop
    - 获取元素左侧和上侧边框的外边缘 距离 最近定位父元素的距离
    - 如果找到根元素都没有定位父级,则以根元素为参考点
  
  * clientLeft和clientTop:获取左边框和上边框的宽度

13. scroll系列属性:
  * scrollWidth 和 scrollHeight:  
    - 获取一个元素内部可滚动总区域的大小
    - 如果不可滚动,则获取的是当前元素的宽和高
  * scrollLeft 和 scrollTop:
    - 获取元素滚动条已经滚过去的距离

14. 全局一些css值的获取:
  * 获取视口的宽度和高度
    - document.documentElement.clientWidth
    - document.documentElement.clientHeight

  * 获取文档的高度
    - document.documentElement.offsetHeight

  * 获取系统滚动条滚动的距离
    - document.documentElement.scrollTop/scrollLeft
    - pageXOffset/pageYOffset


  * 设置系统滚动条滚动的距离
    - document.documentElement.scrollTop/scrollLeft = x;
    - window.scrollTo(x,y)

15. offsetParent属性:
  * 找某个元素的最近定位父元素
  * 如果找不到则是body对象,body标签的offsetParent是null

16. getBoundingClientRect():
  * 返回一个 DOMRect 对象
  * 包含left top right bottom四个属性
  * 分别代表 元素的左边缘和右边缘到视口左边缘的距离 和 元素的上边缘和下边缘到视口上边缘的距离

17. 获取一个元素到文档边缘的距离
  ```js
    function getElToDoc(el) {
      var initEl = el;
      var result = {
        left: 0,
        top: 0,
      };

      while (initEl) {
        if (initEl === el) {
          result.left += initEl.offsetLeft;
          result.top += initEl.offsetTop;
        } else {
          result.left += initEl.offsetLeft + initEl.clientLeft;
          result.top += initEl.offsetTop + initEl.clientTop;
        }
        initEl = initEl.offsetParent;
      }

      return result;
    }
  ```

18. 元素节点常用操作
  * 获取元素:见前几天的课程
  * 创建一个元素:document.createElement("标签名")
  * 把元素(可以是新的或者旧的)插入到某个元素内部的最后边
    - 父元素.appendChild(元素)
  * 把元素A插入到某个元素B的前边,是父元素调用这个方法
    - 父元素.insertBefore(元素A,元素B)
  * 复制一个节点
    - 元素.cloneNode(true/false)
    - 复制元素不会复制元素上的事件
    - 如果cloneNode接受false(默认)作为参数,则只复制标签(浅复制)
    - 如果cloneNode接受true作为参数,复制元素及所有内容(深复制)
  * 替换节点:
    - 父元素.replaceChild(新元素,旧元素)
  * 删除元素
    - 父元素.removeChild(被删除的元素)
    - 被删除的元素.remove() 

19. 元素的内容操作(可读可写)
  * innerHTML
    - 对元素的内部操作
    - 读:能拿到内部所有的标签及内容组成的字符串
    - 写:覆盖原有内部的内容,并能解析字符串内的标签
  * innerText
    - 对元素内部操作
    - 读:只能拿到内部标签的文本内容组成的字符串
    - 写:覆盖原有内部的内容,不能解析字符串内的标签
  * outerHTML
    - 对元素自己操作
    - 读:能拿到当前标签及内部所有标签及内容组成的字符串
    - 写:覆盖原有内容包含自身,并能解析字符串内的标签
  * outerText
    - 对当前元素操作
    - 读:只能拿到内部标签的文本内容组成的字符串
    - 写:覆盖原有内容包含自身,不能解析字符串内的标签
  * textContent
    - 新的属性,替代innerText,用法一致

20. 属性节点的操作:
  * 元素的自有属性(class src id href value)可以直接通过成员访问的方式获取和设置(如果属性名和关键字冲突,则要特殊处理,class==>className for==>htmlFor)
  * 元素的自定义属性(1.给元素做标识  2.让元素保存对应的数据)
  * 旧的自定义属性的操作
    - 给元素设置自定义属性:setAttribute("属性名","属性值")
    - 获取元素某个自定义属性的值:getAttribute("属性名")
    - 删除元素的某个自定义属性:removeAttribute("属性名")
  * 新的自定义属性的操作
    - html5规定所有的自定义属性 必须以 `data-` 为前缀
    - html5还给每一个元素实现了一个dataset属性,是一个对象,代表当前元素的所有html5自定义属性
    - 我们只要对这个对象进行增删改查操作,就是对该元素上的自定义属性进行增删改查的操作

21. 事件模型
  * 事件模型就是 绑定事件的方式
  * 第一种: DOM0事件模型 使用的是 `节点.on+事件名 = 函数`方式使用
  * 第二种: DOM2事件模型 使用`addEventListener`方法实现的
  * 第三种: IE事件模型 使用`attachEvent`方法实现的(淘汰)
  * 第四种: NetScape事件模型(淘汰)

22. 事件流(事件机制)
  * 事件流就是多个节点对象对同一种事件进行响应的先后顺序,主要包括以下3种类型
  * 冒泡型:事件从最特定的目标(target)向最不特定的目标( document对象)触发,也就是事件从内向外进行响应,这个传递过程被形象地称为“冒泡” 
  * 捕获型:事件从最不确定的目标(document对象)开始触发，然后到最特定的目标(target)，也就是事件从外向内进行响应
  * W3C事件流: 支持捕获型和冒泡型两种事件流,其中捕获型事件流先发生,然后才发生冒泡型事件流
    - 捕获阶段
    - 目标阶段
    - 冒泡阶段

23. DOM0绑定事件的特点:
  1. 绑定多次,后边会覆盖前边的
  2. 只能冒泡
  3. 只能绑定DOM0级事件,不能绑定DOM2级事件

24. DOM2绑定事件的方式:
  * 使用 元素.addEventListener()方法绑定事件
  * 参数1: 事件名
  * 参数2: 事件函数
  * 参数3: boolean类型,false代表冒泡,true代表捕获 

25. 移除事件:
  * DOM2的事件,需要使用 removeEventListener方法移除
    - 参数1:事件类型
    - 参数2:事件函数
    - 参数3:事件的捕获还是冒泡
  * DOM0的事件,直接给事件赋值一个null即可移除事件

26. DOMContentLoaded事件:
  - 当所有的节点加载完成后执行
  - DOM2级事件

27. event事件对象:
  * 当事件被触发的时候,会给事件函数传递一个event事件对象,包含当前事件的详细信息
  * 详细属性
    - ctrlKey altKey shiftKey:代表事件发生的时候是否按下对应的键
    - clientX和clientY:事件触发的时候,鼠标到视口边缘的距离
    - offsetX和offsetY:事件触发的时候,鼠标到事件发生的目标元素(target)边缘的距离
    - pageX和pageY:事件触发的时候,鼠标到文档边缘的距离
    - type:事件类型 
    - target:事件目标元素

28. 阻止默认事件:
  * 在浏览器中根据我们的操作,浏览器可能会有默认的功能,但是我们不需要,就要阻止默认事件发生
  * e.preventDefault()

29. 阻止传播:
  * e.stopPropagation() 阻止传播

30. 事件委托:
  * 事件:就是我们开发中绑定的事件
  * 委托:不绑定在自己的身上,绑定在父级或者祖辈元素的上边
  * 使用event事件对象中的target属性获取精确发生事件的元素
  * 原理是:事件冒泡
  * 优点:
    - 减少绑定事件的次数
    - 可以给未来的元素绑定事件

## JS高级
01. prototype属性:
  * 函数分为两大类:1. 普通函数(复用,创建作用域) 2.构造函数(是一个类,实例化就可以得到具体的对象)
  * 每一个函数都有一个prototype属性,但是只有构造函数的prototype才有意义
  * prototype属性默认是一个只拥有constructor属性的对象(原型对象)((显式原型对象))
  * 我们可以给prototype指向的原型对象扩展属性和方法,那么构造函数的实例化对象就可以访问这些扩展的属性和方法
  * prototype上的属性和方法主要是给实例化对象用的,prototype原型对象的方法中的this都是指向实例化对象

02. constructor属性:
  * constructor属性也被称作为构造器属性
  * 每一个原型对象上都有一个constructor属性
  * constructor属性指向其原型对象所在的构造函数
  * 想要确认一个对象是被哪一个构造函数构造出来的,则可以使用constructor属性 

03. __proto__属性:
  * 每一个对象都有一个 __proto__ 属性(隐式原型属性)
  * 指向当前对象的构造函数上的原型对象
  * 对象.__proto__ === 对象的构造函数.prototype
  * !!!!!!对象的隐式原型指向其构造函数的显式原型对象

04. 原型链:
  * 每一个构造函数都有一个prototype属性指向其原型对象
  * 所有的实例对象都有__proto__属性, 它指向其构造函数的原型对象
  * 一个对象通过__proto__属性就形成了一个链的结构===>原型链
  * 当查找对象的属性/方法时, js引擎自动沿着这个原型链查找
  * 当给对象属性赋值时不会使用原型链, 而只是在当前对象中进行操作

05. 闭包:
  * 什么是闭包:是一个函数 以及 其捆绑的周边环境状态的引用 的组合
    - 理解1:函数嵌套函数,内部函数使用外部函数的变量,内部函数被称作为闭包
    - 理解2:在断点调试中,内部函数作用域中包含外部函数变量的closure对象,被称作为闭包
  * 闭包的产生条件
    - 函数嵌套函数
    - 内部函数使用外部函数的变量
    - 外部函数被调用
  * 闭包解决问题:
    - 保护变量:将变量私有化,避免全局污染,内部函数可以访问,外部函数无法访问
    - 延长变量的生命周期:闭包可以让外部函数的变量在函数执行完毕后仍然存在,不会被立即销毁,对于长时间存储数据非常有用,比如计数器
    - 创建私有变量和方法(实现封装):闭包可以创建私有的变量和方法,只能在闭包内部访问,这样就可以避免外部区域操作或者获取私有变量
  * 闭包的缺点:
    - 容易造成内存泄漏
  * 怎么解决闭包容易造成内存泄漏?
    - 及时清除内部函数的引用,内部函数只要销毁,外部函数内的变量也会销毁

06. new做了什么?
  * 首先创建了一个对象
  * 调用构造函数,并把this指向这个对象
  * 把这个对象的隐式原型指向构造函数的原型对象上
  * 根据构造函数返回值的规则,把这个对象返回出去

07. 手写new
  ```js
    function myNew(constr) {
      //首先创建了一个对象
      var o = {};
      //调用构造函数,并把this指向这个对象,re就是这个构造函数调用的返回值
      var re = constr.apply(o, Array.from(arguments).slice(1));
      //把这个对象的隐式原型指向构造函数的原型对象上
      o.__proto__ = constr.prototype;
      //根据构造函数返回值的规则,把这个对象返回出去
      if (
        (typeof re === "object" && re !== null) ||
        typeof re === "function"
      ) {
        return re;
      } else {
        return o;
      }
    }
  ```

08. 创建对象
  * 普通方法创建对象:
    - 创建多个对象代码非常的冗余
  * 工厂模式:封装函数的方法
    - 函数内部直接创建了一个普通的对象,保存属性和方法
    - 调用函数得到的对象 都是object的实例化对象,无法判断这个对象是属于哪一个类
  * 构造函数:
    - 专门用来封装一个 类 的
    - 将来实例化这个构造函数,就可以得到这个类的具象化对象(实例化对象)
    - 并且实例化对象可以通过constructor属性得到他的构造函数是谁
    - 构造函数的书写要求:
      + 首字母大写
      + 只有函数被实例化调用,才能作为真正的构造函数
      + 构造函数被实例化调用后,返回一个实例化对象
      + 构造函数内部的this指向实例化对象
    - 构造函数模式创建对象无法实现 方法共享
  * 构造函数+原型方法:(创建对象的最终方式)
    - 保证实例化对象的属性是私有的,方法是公有的!!!!!

09. 继承:
  * 继承是子类对象能够使用父类对象的数据和行为
  ```js
    //Student类
    function Student(name, age, project) {
      //构造函数继承(调用父类函数,并让父类的this指向子类的实例化对象)
      Person.call(this, name, age);
      this.project = project;
    }
    //原型链继承
    /* 
      错误写法:直接把父类的原型对象 赋值给 子类的原型对象
        问题在于 父类和子类公用一个原型对象
      
      解决方式,除了直接通过 构造函数.prototype访问到原型对象以外,还可以通过构造函数的实例化对象 访问到原型对象上
      所以我们可以把 父类的实例化对象 直接赋值给子类的原型对象
      子类实例化对象寻找方法找不到 会去子类的原型对象(父类的实例化对象)上找,找不到就会找父类的原型对象
    
    */
    Student.prototype = new Person();
    //修正constructor指向
    Student.prototype.constructor = Student;
    //给子类扩展方法
    Student.prototype.study = function () {
      console.log("study");
    };

  ```

10.  多态:
  * 表示一个对象可能存在多种形态(类型),比如[]可以是Array也可以Object

11. 封装:封装的目的是将信息隐藏，一般来说封装包括封装数据、封装实现
  * js使用作用域实现的数据封装
  * js使用函数把细节包装起来，用户都不关心它的内部实现，只需要知道如何使用即可

12. A instanceof B:  
  * 检测B的原型对象 是否在 A的原型链上

13. 手写instanceof
  ```js
    function myInstanceof(A, B) {
      //想法:依次拿到A的原型链上的内容 和B的原型对象判断,如果相等则返回true,都不相等则返回false
      while (A) {
        if (A === B.prototype) {
          return true;
        } else {
          A = A.__proto__;
        }
      }

      return false;
    }
  ```

14. 事件轮询机制:(为什么js是单线程,但是却不阻塞????)
  * js把代码分为了同步和异步
  * 因为整个script区域是异步区域,所以js先执行异步script,然后进入以后先执行同步代码,再执行异步代码
  * 主线程在执行同步代码的时候,如果遇到了异步代码,就会把异步代码的回调函数交给浏览器对应的管理模块管理
  * 浏览器管理模块的回调函数需要被执行的时候,就会把回调函数放在回调队列中
  * 当主线程的代码执行完成后,回去轮询回调队列,执行队列中的回调函数


    

13. 线程与进程
  * 进程：程序的一次执行, 它占有一片独有的内存空间 
  * 线程：进程内的一个独立单元，CPU的基本调度单位, 是程序执行的一个完整流程
  * 注意:
    - 一个进程中一般至少有一个运行的线程: 主线程 
    - 一个进程中也可以同时运行多个线程, 我们会说程序是多线程运行的
    - 一个进程内的数据可以供其中的多个线程直接共享 
    - 多个进程之间的数据是不能直接共享的 
  * JS是单线程的!!!!浏览器是多线程的!!!!!





